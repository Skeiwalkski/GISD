---
title: "GISD - German Index of Socio-Economic Deprivation - Revision 2023"
author: "Omar Soliman, Marvin Reis"
date: "21 11 2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 0. Benötigte Pakete und Dateipfadsetzung

```{r Libraries, message=FALSE, warning=FALSE, include=FALSE}

library("tidyverse") # Tidyverse Methods
library("bookdown") # Tools for RMarkdown
library("writexl") # Write Excel
library("readxl") # Read Excel
library("imputeTS") # Impute Missing Features
library("haven") # Write Stata-dta
library("sf") # Geospatial Data Manipulation
library("pastecs") # Descriptive stats
library("rvest") # API-Scraper
library("rjstat") # JSON-Stat Parser
```


```{r Path Definitions, message=FALSE, warning=FALSE, include=FALSE}
home <- getwd()

currentyear <- 2020
currentrevision <- "2023_v1"

# Define Outfiles Directory 
#outfiles_dir <- "S:/OE/FG28/205 Regionale Unterschiede/GISD/"
#outfiles_daten <- "C:/projects_rstudio/GISD/Outfiles"
#setwd(outfiles_daten)

# Create Output directories in working directory if necessary
dir.create("Outfiles", showWarnings=T)
dir.create(paste0("Outfiles/",currentrevision), showWarnings=T)
dir.create(paste0("Outfiles/",currentrevision,"/Bund"), showWarnings=T)
dir.create(paste0("Outfiles/",currentrevision,"/Other"), showWarnings=T)
dir.create(paste0("Outfiles/",currentrevision,"/Stata"), showWarnings=T)
```

## I.  Generierung eines ID-Datensatzes

Zunächst wird ein Datensatz (ID-Datensatz) generiert, in welchem den kleinsten regionalen Einheiten (Gemeinden) allen übergeordneten regionalen Einheiten und deren Regionalkennziffern zugeordnet werden. Dazu werden Referenzdateien aus der Dokumentation INKAR-Datenbank verwendet [https://www.inkar.de/]. Es wird dabei geprüft, ob die Referenzdaten Missings auf den Regionalkennziffern oder den Namen der Gebietsstände aufweisen.


```{r ID-Datensatz aus den Referenzdaten generieren , message=FALSE, warning=FALSE}

# Referenz laden/generieren
if (!file.exists("Data/Referenz/Erzeugte Referenzen/Referenz_1998_2020.xlsx")) { # Falls noch nicht vorhanden
  source("Data/Referenz/Generate_Reference_2020.R") # Skript wurde per Hand geschrieben, muss jährlich aktualisiert werden
  }

# Funktion zum NA-Values ausgeben lassen
print_missings = function(data) {
  df = data[-1,];        # Erste Reihe exkludieren
  if(sum(is.na(df))>0)   # Wenn mind. 1 Datenpunkt NA ist, dann:
  {print("Missing observations: ");   # Printe Präfix
    print(df[!complete.cases(df),])}; # Printe jede Zeile wo es eine Spalte mit NA gibt
  df}                    # Returne den Datensatz

# Funktion zum Sheets aus Referenz laden
load_dataset = function(sheet) {
  suppressMessages(
    read_excel("Data/Referenz/Erzeugte Referenzen/Referenz_1998_2020.xlsx",
               sheet = sheet, na = "NA")) 
}   # Achtung: Referenz wird per Hand geupdated seit BBSR nicht mehr rausgibt
    # Änderung für Generate 2020: Leipzig geändert von DED3 auf DED5, Chemnitz von DED1 auf DED4
    # (Angleichung an NUTS-Reform 2011 - Hat BBSR verpasst)


Gemeinden_INKAR <- load_dataset("Gemeinden-GVB") %>% 
  na.omit() %>%
  mutate(Kennziffer=as.numeric(gkz),
         GVBKennziffer=gvb_kz_lang,
         flaeche=as.numeric(flaeche))

Gemeindeverbaende_INKAR <- load_dataset("Gemeindeverbände") %>% 
  na.omit() %>% 
  select(GVBKennziffer = gvb_kz_lang, # Es werden 8-Stellige (kurz) und 9-Stellige (lang) GVB-Kennziffern angeboten
         "Name des Gemeindeverbands" = gvbname)

Kreise_INKAR <- load_dataset("KRS") %>%
  mutate(kkz = as.numeric(kkz),
         flaeche = as.numeric(flaeche))



# Die drei Datensätze werden nun ausgehend vom Gemeindedatensatz zu einem ID-Datensatz zusammmengefügt
id_dataset <- Gemeinden_INKAR %>% 
              select(Gemeindekennziffer = Kennziffer,
                     "Name der Gemeinde" = gemeindename,
                     GVBKennziffer,
                     Bevoelkerung) %>% 
              mutate(Kreiskennziffer=floor(Gemeindekennziffer/1000)) %>% #Bitte für jedes Jahr neu prüfen ob Population in 100ern oder in 1000ern angegeben wird
              left_join(., Kreise_INKAR %>% select("Kreiskennziffer"=kkz,
                                                  "Name des Kreises"=kreisname,
                                                  "Raumordnungsregion Nr"=ROR11,
                                                  "Raumordnungsregion"=ROR11name,
                                                  NUTS2,
                                                  "NUTS2 Name"=NUTS2name,
                                                  "Bundesland"=Bundesland),
                        by="Kreiskennziffer") %>%
              left_join(.,Gemeindeverbaende_INKAR, by="GVBKennziffer")

write_rds(id_dataset, paste0("Outfiles/",currentrevision,"/ID_dataset_",currentrevision,".rds"))
```

## II. Erzeugen eines Datensatzes mit Kennziffern als ID unabhängig von der Ebene 

In diesem Kapitel werden die Daten der Indikatoren eingelesen und in einem Datensatz zusammengeführt. Die Werte der Indikatoren, die für die Berechnung des GISD verwendet werden, liegen entweder auf Ebende der Gemeinde und Gemeindeverbände oder auf Ebene der Stadt- und Landkreise vor. Die Faktorenanalyse zur Bestimmung der Gewichte soll später auf der Gemeindeebene durchgeführt werden. Deshalb werden Informationen der höheren Ebenen jeweils an alle Gemeinden dieser Kreise angespielt. Quelle sind die INKAR-Daten der jeweiligen Indikatoren im Excel-Format, die für jede Revision aus der INKAR-Datenbank heruntergeladen werden. Tabelle \@ref(tab:indicators) stellt die Indikatoren dar.
Für einige Indikatoren, die nur in absoluten Zahlen vorliegen, werden in diesem Kapitel Quoten bzw. Anteile berechnet: Arbeitslose pro 1000 Einwohner im Erwerbsalter, Anteil der SV Beschäftigte ohne Abschluss sowie der Anteil der SV Beschäftigten mit akad. Abschluss an allen SV Beschäftigten. 
Gemeinden ohne Bevölkerung werden ausgeschlossen.


```{r Indikatoren einlesen und mit dem ID-Datensatz Zusammeführen, message=FALSE}

# Basisdaten mit allen Kennziffern und Bevölkerung: Kreisebene
Basedata <- Kreise_INKAR %>%
  select(Kennziffer=kkz) %>%
  mutate(Jahr=currentyear)

# Liste der Variablen generieren
inputdataset <- list.files("Data/INKAR_1998_2020") %>%
  .[str_detect(., "\\.xlsx$")] # Alle Excel Files im Ordner auflisten

inputdataset

# Einlesen der einzelnen Excelfiles zu den Daten 
for(file in inputdataset){
  suppressMessages(myimport <- read_excel(paste0("Data/INKAR_1998_2020/", file),
                                          skip = 1, sheet = "Daten"))
  names(myimport)[1] <- "Kennziffer"
  myimport[2:3] <- NULL # Zweite und dritte Spalte entfernen
  myimport <- myimport %>%
    gather(key = "Jahr", # Umwandeln von Wide zu Long - Das Jahr nun Zeilenweise statt Spaltenweise
           value = "Value", -"Kennziffer", convert = T, na.rm = T) %>%
    mutate(Kennziffer = as.numeric(as.character(Kennziffer)),
           Value = as.numeric(Value))
  names(myimport)[3] <- strsplit(strsplit(file,"_")[[1]][2],"[.]")[[1]][1] # Dateiname als Variablenname
  Basedata <- full_join(Basedata, myimport, by=c("Kennziffer", "Jahr"))    # Zu Basedata hinzufügen
}

rm(inputdataset, file)

# Liste der Indikatoren erstellen
listofdeterminants <- names(Basedata)[3:length(Basedata)]

# Regionale Tiefe der Indikatoren 
ind_level <- c("Gemeindeverband","Gemeindeverband","Kreis", "Gemeindeverband", "Kreis", "Kreis", "Kreis", "Kreis", "Kreis", "Gemeindeverband", "Kreis", "Kreis")
level_table <- cbind(listofdeterminants,ind_level)
# Tabelle der Indikatoren mit regionaler Tiefe
ind_col = c("Indikator","Tiefe des Indikators")


# Basisdaten mit allen Kennziffern mit Bevölkerung (2020): Gemeindverbandsebene
Basedata_Gemeindeverbandsebene <- Basedata %>% 
  select("Gemeindeverband" = Kennziffer,
         Jahr, Arbeitslosigkeit, Beschaeftigtenquote,
         ErwerbsfaehigeBevoelkerung, Einkommensteuer) %>%   
  gather(key, value, 3:6) %>% #Indikatoren im Sinne des Long-Formats untereinander anzeigen
  filter(!is.na(value)) %>% #Missings rauswerfen - Es sollten nur noch Gemeindeverbände übrig sein
  spread(key, value) %>% #Zurück ins Wide-Format - Eine Spalte pro Indikator
  filter(Jahr>=1998)

# Weiterer Datensatz der Kreisebene um Daten, die auf GVBN-Ebene fehlen,
# mit Kreisinformationen aufzufüllen (vor allem 1998-2000)
Basedata_Kreisebene <- Basedata %>%
  select(Kreis = Kennziffer,
         Jahr, all_of(listofdeterminants)) %>% 
  select(-Arbeitslosigkeit, -Einkommensteuer,
         -Beschaeftigtenquote, -ErwerbsfaehigeBevoelkerung) %>% 
  filter(Jahr>=1998)


# Daten der verschiedenen Ebenen zusammenspielen
Workfile <- as.data.frame(expand.grid("Kennziffer" = Gemeinden_INKAR %>% pull(Kennziffer),
                                      "Jahr" = seq(min(Basedata$Jahr):max(Basedata$Jahr)) + min(Basedata$Jahr)-1)) %>%
  mutate(Kreiskennziffer = floor(as.numeric(Kennziffer)/1000)) %>%
  as_tibble() %>%
  left_join(., Gemeinden_INKAR, by=c("Kennziffer")) %>%
  select(Gemeindekennziffer="Kennziffer",
         Kreis="Kreiskennziffer",
         Gemeindeverband=GVBKennziffer,
         Jahr, Bevoelkerung) %>%
  mutate(Gemeindeverband=as.numeric(Gemeindeverband),
         Bevoelkerung=as.numeric(Bevoelkerung)) %>% 
  arrange("Gemeindeverband","Jahr") %>% # Join Metadata
   left_join(. , Basedata_Kreisebene, by=c("Kreis","Jahr")) %>%
   left_join(. , Basedata_Gemeindeverbandsebene, by=c("Gemeindeverband","Jahr")) %>%
   filter(Jahr>=1998)

rm(myimport)


##Anspielen der NUTS-2 Indikatoren anhand der Eurostat API

if (!file.exists("Data/INKAR_1998_2020/NUTS2/NUTS2data.xlsx")) { #Wenn Daten noch nicht vorhanden, dann aus dem Internet ziehen
  # Bevölkerung am Wohnort mit akademischem Abschluss
  apicall.NUTS2_noedu <- "https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/EDAT_LFSE_04?format=JSON&lang=en&freq=A&sex=T&isced11=ED0-2&age=Y25-64&unit=PC&geo=DE11&geo=DE12&geo=DE13&geo=DE14&geo=DE21&geo=DE22&geo=DE23&geo=DE24&geo=DE25&geo=DE26&geo=DE27&geo=DE30&geo=DE40&geo=DE50&geo=DE60&geo=DE71&geo=DE72&geo=DE73&geo=DE80&geo=DE91&geo=DE92&geo=DE93&geo=DE94&geo=DEA1&geo=DEA2&geo=DEA3&geo=DEA4&geo=DEA5&geo=DEB1&geo=DEB2&geo=DEB3&geo=DEC0&geo=DED2&geo=DED4&geo=DED5&geo=DEE0&geo=DEF0&geo=DEG0&sinceTimePeriod=2000"
  
  NUTS2_noedu <- fromJSONstat(html_text2(read_html(apicall.NUTS2_noedu))) %>%
    mutate(Jahr = as.numeric(Time),
           BevoelkerungohneAbschluss = value,
           Region = `Geopolitical entity (reporting)`) %>%
    select(Jahr, Region, BevoelkerungohneAbschluss)
  
  
  # Bevölkerung am Wohnort ohne Berufsabschluss
  apicall.NUTS2_higheredu <- "https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/EDAT_LFSE_04?format=JSON&lang=en&freq=A&sex=T&isced11=ED5-8&age=Y25-64&unit=PC&geo=DE11&geo=DE12&geo=DE13&geo=DE14&geo=DE21&geo=DE22&geo=DE23&geo=DE24&geo=DE25&geo=DE26&geo=DE27&geo=DE30&geo=DE40&geo=DE50&geo=DE60&geo=DE71&geo=DE72&geo=DE73&geo=DE80&geo=DE91&geo=DE92&geo=DE93&geo=DE94&geo=DEA1&geo=DEA2&geo=DEA3&geo=DEA4&geo=DEA5&geo=DEB1&geo=DEB2&geo=DEB3&geo=DEC0&geo=DED2&geo=DED4&geo=DED5&geo=DEE0&geo=DEF0&geo=DEG0&sinceTimePeriod=2000"
  
  NUTS2_higheredu <- fromJSONstat(html_text2(read_html(apicall.NUTS2_higheredu))) %>%
    mutate(Jahr = as.numeric(Time),
           BevoelkerungmitakadAbschluss = value,
           Region = `Geopolitical entity (reporting)`) %>%
    select(Jahr, Region, BevoelkerungmitakadAbschluss)

    
  # Zusammenführen
  NUTS2 <- full_join(NUTS2_noedu, NUTS2_higheredu, by = c("Region", "Jahr")) %>% 
    left_join(distinct(id_dataset %>% select(NUTS2, `NUTS2 Name`)),
              by = c("Region" = "NUTS2 Name")) # %>% select(-Region)
  
  rm(apicall.NUTS2_noedu, apicall.NUTS2_higheredu, NUTS2_noedu, NUTS2_higheredu)
  
  write_xlsx(NUTS2, "Data/INKAR_1998_2020/NUTS2/NUTS2data.xlsx")
  
} else { #Wenn Daten schon vorhanden, dann einfach laden
  NUTS2 <- read_excel("Data/INKAR_1998_2020/NUTS2/NUTS2data.xlsx")
}

NUTS2 <- NUTS2 %>%
  left_join(., id_dataset, by = "NUTS2") %>%
  mutate(Gemeindeverband = GVBKennziffer) %>%
  select(Jahr, BevoelkerungmitakadAbschluss,
         BevoelkerungohneAbschluss, Gemeindeverband)

Workfile <- Workfile %>%
  left_join(., NUTS2, by = c("Gemeindeverband", "Jahr")) %>%
  distinct()

rm(NUTS2)

##Anspielen der Arbeitslosigkeit und Erwerbsbevölkerung auf Kreisebene

inputdataset <- list.files("Data/INKAR_1998_2020/Indikatoren_Kreisebene/")

for(file in inputdataset){
  suppressMessages(myimport <- read_excel(paste0("Data/INKAR_1998_2020/Indikatoren_Kreisebene/",file), skip = 1, sheet = "Daten"))
  names(myimport)[1] <- "Kennziffer"
  myimport[2:3] <- NULL
  myimport <- myimport %>%
    gather(key = "Jahr", value = "Value" , -"Kennziffer", convert=T, na.rm = T) %>%
    mutate(Kennziffer=as.numeric(as.character(Kennziffer)), Value=as.numeric(Value))
  
  names(myimport)[3] <- strsplit(strsplit(file,"_")[[1]][2],"[.]")[[1]][1]
  myimport <- myimport %>% mutate(Kreis = Kennziffer) %>% select(-Kennziffer)
  Workfile <- full_join(Workfile, myimport, by=c("Kreis", "Jahr"))
}

## Ersetzen fehlender Daten auf Gemeindeverbandsebene durch Daten der Kreisebene (Jahre 1998 bis 2000)

Workfile <- Workfile %>%
  mutate(ErwerbsfaehigeBevoelkerung = ifelse(Jahr < 2001, ErwerbsfaehigeBevoelkerungKreis, ErwerbsfaehigeBevoelkerung),
         Arbeitslosigkeit = ifelse(Jahr < 2001, ArbeitslosigkeitKreis, Arbeitslosigkeit),
         Beschaeftigtenquote = ifelse(Jahr < 2001, BeschaeftigtenquoteKreis, Beschaeftigtenquote)) %>%
  select(-ErwerbsfaehigeBevoelkerungKreis, -ArbeitslosigkeitKreis, -BeschaeftigtenquoteKreis)

rm(myimport)

##Erstellen eines Datensatzes mit Bevölkerungslosen Gemeinden und Entfernen dieser für die bevorstehende Imputation und die Faktoranalyse
Gemeinden_ohne_Bevoelkerung <- Workfile %>% filter(Bevoelkerung==0)
write_dta(Gemeinden_ohne_Bevoelkerung, paste0("Outfiles/",currentrevision,"/Gemeinden_ohne_Bevoelkerung.dta"))
rm(Gemeinden_ohne_Bevoelkerung)


#Berechnung der Anteile für Beschäftigte ohne Abschluss, Beschäftigte mit akad. Abschluss und Entfernen SV Beschäftigte (total)
Workfile <- Workfile %>% filter(Bevoelkerung>0) %>% mutate(BeschaeftigteohneAbschluss = round(BeschaeftigteohneAbschluss / SVBeschaeftigte * 100, digits = 2), BeschaeftigtemitakadAbschluss = round(BeschaeftigtemitakadAbschluss / SVBeschaeftigte * 100, digits = 2)) %>%
  select(-SVBeschaeftigte)
Basedata <- Basedata %>% select(-SVBeschaeftigte)
Basedata_Kreisebene <- Basedata_Kreisebene %>% select(-SVBeschaeftigte)
level_table <- level_table[-9,]
listofdeterminants <- listofdeterminants[-9]


#Berechnung der Quote für Arbeitslosigkeit und Entfernen Erwerbsfähige Bevölkerung
Workfile <- Workfile %>% filter(Bevoelkerung>0) %>% mutate(Arbeitslosigkeit = ifelse(is.na(ErwerbsfaehigeBevoelkerung),NA,round(Arbeitslosigkeit / ErwerbsfaehigeBevoelkerung * 1000, digits = 2)), Arbeitslosigkeit=ifelse(is.nan(Arbeitslosigkeit),NA,Arbeitslosigkeit),
     Arbeitslosigkeit=ifelse(is.infinite(Arbeitslosigkeit),NA,Arbeitslosigkeit)) %>% select(-ErwerbsfaehigeBevoelkerung)
Basedata <- Basedata %>% select(-ErwerbsfaehigeBevoelkerung)
Basedata_Gemeindeverbandsebene <- Basedata_Gemeindeverbandsebene %>% select(-ErwerbsfaehigeBevoelkerung)
level_table <- level_table[-4,]
listofdeterminants <- listofdeterminants[-4]


##Ausschreiben eines Vorab-Workfiles zur Überprüfung der Arbeitslosenquote
Workfile <- Workfile %>% filter(Bevoelkerung>0)
write_dta(Workfile, paste0("Outfiles/",currentrevision,"/Workfile_vorab.dta"))


# Stata-Datensatz rausschreiben
#write_dta(Workfile, paste0("S:/OE/FG28/205 Regionale Unterschiede/GISD/Plausibilitätschecks/workfile.dta"))


# Ende Generierung Basisdatensatz
```

```{r indicators, echo=FALSE}
knitr::kable(level_table, col.names = ind_col, caption = "Liste der Indikatoren")
```


## III. Anpassungen

- Anpassung von Einkommensteuer, Haushaltsankommen und Bruttoverdienst an Verbraucherpreisindex
- Logarithmierung von Einkommensteuer, Haushaltseinkommen, Bruttoverdienst

Quelle VBP-Index: https://www.destatis.de/DE/Themen/Wirtschaft/Preise/Verbraucherpreisindex/Publikationen/Downloads-Verbraucherpreise/verbraucherpreisindex-lange-reihen-pdf-5611103.html

```{r Logarithmierung und Anpassung durch Verbraucherpreisindex}

Verbraucherpreisindex <- data.frame(Jahr = seq(1998, currentyear),
                                    VBindex =  c(78.3, 78.8,
                                                 79.9, 81.5, 82.6, 83.5, 84.9,
                                                 86.2, 87.6, 89.6, 91.9, 92.2,
                                                 93.2, 95.2, 97.1, 98.5, 99.5,
                                                 100, 100.5, 102, 103.8, 105.3,
                                                 105.8))

Workfile <- Workfile %>% left_join(Verbraucherpreisindex, by = "Jahr")

Workfile <- Workfile %>% mutate(Einkommensteuer = Einkommensteuer / VBindex * 100, Haushaltseinkommen = Haushaltseinkommen / VBindex * 100, Bruttoverdienst = Bruttoverdienst / VBindex * 100)


Workfile <- Workfile %>% mutate(Einkommensteuer_ln = ifelse(Einkommensteuer==0, 0.75, log(Einkommensteuer)))

Workfile <- Workfile %>% mutate(Haushaltseinkommen_ln = log(Haushaltseinkommen))

Workfile <- Workfile %>% mutate(Bruttoverdienst_ln = log(Bruttoverdienst))

```

- Erstellen von Hilfsvariablen zur Identifizierung von bildungspolitischen Reformen (G8)
- Adjustment der Schulabgänger Indikatoren anhand von Reformeffekten (Koeffizient des Effekts wird vom Indikator abgezogen)
- Check des Adjustments durch Histogramm

```{r Erstellen Variabe zu G8 und Sensibilisierung des Datensatzes}
# Die Bildungsvariablen Anteil der Schulabgänger mit Hochschulreife und Anteil der Schulabgänger ohne Abschluss werden als Quote relativ zur Gesamtanzahl der Schulabgänger berechnet. Durch die G8-Schulreformen und ihre Zurücknahme ergeben sich deshalb in den Bundesländern zu verschiedenen Zeitpunkten Verzerrungen. Diese Verzerrung wird über ein Regressionsmodell herausgerechnet.

# Generierung der Variablen zur Identifikation der Reformen (G8), Rückker zu G9 (SN_KA) und abweichender Anerkennung von Abschlüssen für GymnasiastInnen (THvor2004)

Workfile <- Workfile %>%
  mutate(G8_jahr = case_when(Kreis < 2000 & Jahr == 2016 ~ 1,
                                Kreis > 1999 & Kreis < 3000 & Jahr == 2010 ~ 1,
                                Kreis > 2999 & Kreis < 4000 & Jahr == 2011 ~ 1,
                                Kreis > 3999 & Kreis < 5000 & Jahr == 2012 ~ 1,
                                Kreis > 4999 & Kreis < 6000 & Jahr == 2013 ~ 1,
                                Kreis > 5999 & Kreis < 7000 & Jahr == 2013 ~ 1,
                                Kreis > 7999 & Kreis < 9000 & Jahr == 2012 ~ 1,
                                Kreis > 8999 & Kreis < 10000 & Jahr == 2011 ~ 1,
                                Kreis > 9999 & Kreis < 11000 & Jahr == 2009 ~ 1,
                                Kreis > 10999 & Kreis < 12000 & Jahr == 2012 ~ 1,
                                Kreis > 11999 & Kreis < 13000 & Jahr == 2012 ~ 1,
                                Kreis > 12999 & Kreis < 14000 & Jahr == 2008 ~ 1,
                                Kreis > 14999 & Kreis < 16000 & Jahr == 2007 ~ 1),
         SN_KA = ifelse(Jahr == 2001 & Kreis > 14999 & Kreis < 16000, 1, 0),
         THvor2004 = ifelse(Jahr < 2004 & Kreis > 15999, 1, 0))
Workfile$G8_jahr[is.na(Workfile$G8_jahr)] = 0
Workfile$SN_KA[is.na(Workfile$SN_KA)] = 0
Workfile$THvor2004[is.na(Workfile$THvor2004)] = 0


# Anpassung: Ersetzen der Werte in den von Verzerrungen betroffenen Fälle durch um Reformeffekte bereinigte Quoten.
adj_G8_jahr <- function(data,outcome_name){
  mydata   <- data %>%
    group_by(Gemeindekennziffer) %>% 
    select(Gemeindekennziffer, Jahr, G8_jahr, SN_KA, THvor2004, "Outcome"=paste(outcome_name)) %>% 
    mutate(MEAN=mean(Outcome , na.rm=T)) %>% ungroup()
  
    mymodell2 <- lm(Outcome ~
                  I(Jahr*Jahr*MEAN) + I(Jahr*MEAN) + G8_jahr + SN_KA + THvor2004, data = mydata  , na.action="na.exclude")
  print(mymodell2)
    mydata %>% mutate(coef = summary(mymodell2)$coefficients[4,1], coef_SH = summary(mymodell2)$coefficients[5,1], coef_TH = summary(mymodell2)$coefficients[6,1]) %>%
      mutate(Outcome = ifelse(G8_jahr == 1, Outcome - coef, Outcome), Outcome = ifelse(SN_KA == 1, Outcome - coef_SH, Outcome), Outcome = ifelse(THvor2004 == 1, Outcome - coef_TH, Outcome)) %>%
      pull(Outcome)
}

Workfile <- Workfile %>% 
  mutate(SchulabgaengermitHochschulreife_adj = adj_G8_jahr(.,"SchulabgaengermitHochschulreife"),
         SchulabgaengerohneAbschluss_adj = adj_G8_jahr(.,"SchulabgaengerohneAbschluss"))


#Adjustmentprüfung
hist_over_SchulabgaengerohneAbschluss <- ggplot() +
  geom_histogram(data = Workfile[Workfile[,"G8_jahr"]==0,], aes_string(x = "SchulabgaengerohneAbschluss"), fill ='darkblue')  + 
  geom_histogram(data = Workfile[Workfile[,"G8_jahr"]==1,], aes_string(x = "SchulabgaengerohneAbschluss"), fill ='darkred')

hist_over_SchulabgaengerohneAbschluss_adj <- ggplot() +
  geom_histogram(data = Workfile[Workfile[,"G8_jahr"]==0,], aes_string(x = "SchulabgaengerohneAbschluss_adj"), fill ='darkblue')  + 
  geom_histogram(data = Workfile[Workfile[,"G8_jahr"]==1,], aes_string(x = "SchulabgaengerohneAbschluss_adj"), fill ='darkred')

hist_over_SchulabgaengerohneAbschluss
hist_over_SchulabgaengerohneAbschluss_adj
```


- Erstellen von Hilfsvariablen zur Identifikation von Ost und West Kreisen
- Adjustment des Beschäftigte ohne Abschluss Indikatoren anhand von Ost-West-Unterschieden (Koeffizient des Effekts wird vom Indikator abgezogen)
- Check des Adjustments durch Histogramm

```{r Sensibilisierung auf Ost-west-Unterschiede}

Workfile <- Workfile %>% mutate(OW = ifelse(Kreis < 11000, 0, 1))

# mydata   <- Workfile %>%
#    select(Gemeindekennziffer, Jahr, OW, BeschaeftigteohneAbschluss) %>% 
#    mutate(Jahr_Dummy = as.factor(Jahr)) %>% ungroup()
#  
#    mymodell_ow <- lm(BeschaeftigteohneAbschluss ~ Jahr_Dummy + relevel(Jahr_Dummy, ref = "2012") * OW, data = #mydata, na.action="na.exclude")
#
#    summary(mymodell_ow)
#    summary(mymodell_ow)$coefficients[18,1]

    #Adjustmentprüfung
hist_over_westost <- ggplot() +
  geom_histogram(data = Workfile[Workfile[,"Kreis"]<11000,], aes_string(x = "BeschaeftigteohneAbschluss"), fill ='darkblue')  + 
  geom_histogram(data = Workfile[Workfile[,"Kreis"]>=11000,], aes_string(x = "BeschaeftigteohneAbschluss"), fill ='darkred') 

 
OW <- function(data,outcome_name){ #Diese Funktion zieht den Ostwest-Koeffizienten aus jeder Regression
  mydata   <- data %>%
    select(Gemeindekennziffer, Jahr, OW, "Outcome"=paste(outcome_name)) %>% 
    mutate(Jahr_Dummy = as.factor(Jahr)) %>% ungroup()
  
    mymodell_ow <- lm(Outcome ~ Jahr_Dummy + relevel(Jahr_Dummy, ref = "2012") * OW, data = mydata, na.action="na.exclude")
    
  print(mymodell_ow)
    mydata %>% mutate(coef = summary(mymodell_ow)$coefficients["OW",1]) %>%
      mutate(Outcome = ifelse(OW == 1, Outcome - coef, Outcome)) %>%
      pull(Outcome)
}

Workfile <- Workfile %>% 
  mutate(BeschaeftigteohneAbschluss_adj = OW(.,"BeschaeftigteohneAbschluss"))


hist_over_westost_adj <- ggplot() +
  geom_histogram(data = Workfile[Workfile[,"Kreis"]<11000,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkblue')  + 
  geom_histogram(data = Workfile[Workfile[,"Kreis"]>=11000,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkred')

hist_over_westost
hist_over_westost_adj
```

- Erstellen von Hilfsvariablen um Änderung der Messung von SV Beschäftigten am Wohnort festzustellen
- Adjustment der SV Beschäftigte Indikatoren anhand von Änderungseffekten (Koeffizient des Effekts nach 2012 wird auf Indikator draufgerechnet)
- Check des Adjustments durch Histogramm

```{r Messänderung}
#BeschaeftigteohneAbschluss
Workfile_spread <- Workfile %>% filter(Jahr == 2013) %>% spread(key = Jahr, value = BeschaeftigteohneAbschluss_adj) %>% select("2013", Gemeindekennziffer ) %>% mutate(Jahr = 2012) %>% rename(BeschaeftigteohneAbschluss_adj = "2013")

Workfile <- Workfile %>% left_join(Workfile_spread, by = c("Gemeindekennziffer", "Jahr")) %>% mutate(BeschaeftigteohneAbschluss_adj = ifelse(Jahr == 2012, BeschaeftigteohneAbschluss_adj.y, BeschaeftigteohneAbschluss_adj.x)) %>% select(-BeschaeftigteohneAbschluss_adj.y, -BeschaeftigteohneAbschluss_adj.x)

#BeschaeftigtemitakadAbschluss
Workfile_spread <- Workfile %>% filter(Jahr == 2013) %>% spread(key = Jahr, value = BeschaeftigtemitakadAbschluss) %>% select("2013", Gemeindekennziffer ) %>% mutate(Jahr = 2012) %>% rename(BeschaeftigtemitakadAbschluss = "2013")

Workfile <- Workfile %>% left_join(Workfile_spread, by = c("Gemeindekennziffer", "Jahr")) %>% mutate(BeschaeftigtemitakadAbschluss = ifelse(Jahr == 2012, BeschaeftigtemitakadAbschluss.y, BeschaeftigtemitakadAbschluss.x)) %>% select(-BeschaeftigtemitakadAbschluss.y, -BeschaeftigtemitakadAbschluss.x)


Workfile <- Workfile %>% mutate(Messaenderung_Besch = ifelse(Jahr > 2012, 1, 0))

hist_over_vor_messanpassung <- ggplot() +
  geom_histogram(data = Workfile[Workfile[,"Jahr"]<2013,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkblue')  + 
  geom_histogram(data = Workfile[Workfile[,"Jahr"]>=2013,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkred')  

#mydata   <- Workfile %>% 
#    select(Gemeindekennziffer, Jahr, Messaenderung_Besch, BeschaeftigteohneAbschluss_adj) %>% 
#    mutate(MEAN=mean(BeschaeftigteohneAbschluss_adj , na.rm=T)) %>% ungroup()
#
#  mymodell_Messaenderung <- lm(BeschaeftigteohneAbschluss_adj ~
#                  I(Jahr*Jahr*MEAN) + I(Jahr*MEAN) + Messaenderung_Besch, data = mydata  , na.action="na.exclude")
#
#  summary(mymodell_Messaenderung)
#  summary(mymodell_Messaenderung)$coefficients[4,1]
  

Messaenderung <- function(data,outcome_name){
  mydata   <- data %>%
    select(Gemeindekennziffer, Jahr, Messaenderung_Besch, "Outcome"=paste(outcome_name)) %>% 
    mutate(MEAN=mean(Outcome , na.rm=T)) %>% ungroup()
  
  mymodell_Messaenderung <- lm(Outcome ~
                  I(Jahr*Jahr*MEAN) + I(Jahr*MEAN) + Messaenderung_Besch, data = mydata  , na.action="na.exclude")
  
  print(mymodell_Messaenderung) 
  summary(mymodell_Messaenderung)$coefficients["Messaenderung_Besch",1]
    mydata <- mydata %>% 
      mutate(coef = summary(mymodell_Messaenderung)$coefficients["Messaenderung_Besch",1]) %>%
      mutate(Outcome = ifelse(Jahr < 2012, Outcome + coef, Outcome)) %>%
      pull(Outcome)
}

Workfile <- Workfile %>% 
  mutate(BeschaeftigteohneAbschluss_adj = Messaenderung(.,"BeschaeftigteohneAbschluss_adj"),
         BeschaeftigtemitakadAbschluss_adj = Messaenderung(.,"BeschaeftigtemitakadAbschluss"))

#Adjustmentprüfung
hist_over_nach_messanpassung <- ggplot() +
  geom_histogram(data = Workfile[Workfile[,"Jahr"]<2013,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkblue')  + 
  geom_histogram(data = Workfile[Workfile[,"Jahr"]>=2013,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkred')

hist_over_vor_messanpassung
hist_over_nach_messanpassung

```


- Imputation der Missings für die restlichen Indikatoren (Regression auf Basis von Arbeitslosigkeit und Schulabgänger ohne Abschluss)
- Imputation für NUTS-2 Indikatoren auf Bundeslandbene (Regression auf Basis von Arbeitslosigkeit und Schulabgänger ohne Abschluss)
- Imputation für Schulabgänger mit Hochschlusabschluss (Regression auf Basis aller Indikatoren)
- Erneute Ausgabe möglicher Missings

```{r}
# Imputation

# Imputationsdatensatz generieren
Impdata <-  Workfile %>%  filter(Jahr>=1998) %>% 
  gather(key,value,6:15) %>% mutate(value=ifelse(value<0.00001,NA,value)) %>% spread(key,value)

listofdeterminants <- c("Arbeitslosigkeit", "SchulabgaengerohneAbschluss_adj", "Beschaeftigtenquote", "Bruttoverdienst_ln", "BeschaeftigtemitakadAbschluss_adj", "BeschaeftigteohneAbschluss_adj", "Einkommensteuer_ln", "Haushaltseinkommen_ln", "Schuldnerquote", "BevoelkerungohneAbschluss", "BevoelkerungmitakadAbschluss", "SchulabgaengermitHochschulreife_adj")


# Impute_function (NOT FOR GROUPED DATA!)
my_ts_imputer <- function(data,outcome_name){
  mydata   <- data %>% group_by(Gemeindekennziffer) %>%
    select(Gemeindekennziffer,Jahr,"Outcome"=paste(outcome_name)) %>% 
    mutate(MEAN=mean(Outcome , na.rm=T)) %>% ungroup()
  mymodell <- lm(Outcome ~
                  I(Jahr*Jahr*MEAN) + I(Jahr*MEAN),
                   data = mydata  , na.action="na.exclude")
  mydata %>% select(Outcome) %>% mutate(Imputed = predict(mymodell, newdata =mydata )) %>%
    mutate(Outcome=ifelse(is.na(Outcome),Imputed,Outcome)) %>% 
    mutate(Outcome=ifelse(is.nan(Outcome),Imputed,Outcome)) %>%
    mutate(Outcome=ifelse(is.infinite(Outcome),Imputed,Outcome)) %>%
    mutate(Outcome=ifelse(Outcome<0,0,Outcome)) %>% pull(Outcome)
}


# hier wird der Datensatz mit den imputierten Werten generiert
Impdata.imputed <- Impdata %>%
  mutate(Arbeitslosigkeit=my_ts_imputer(.,"Arbeitslosigkeit"),
         SchulabgaengerohneAbschluss_adj=my_ts_imputer(.,"SchulabgaengerohneAbschluss_adj"),
         SchulabgaengerohneAbschluss=my_ts_imputer(.,"SchulabgaengerohneAbschluss"),
         Beschaeftigtenquote=my_ts_imputer(.,"Beschaeftigtenquote"),
         Bruttoverdienst_ln=my_ts_imputer(.,"Bruttoverdienst_ln"),
         Bruttoverdienst=my_ts_imputer(.,"Bruttoverdienst"),
         BeschaeftigtemitakadAbschluss_adj=my_ts_imputer(.,"BeschaeftigtemitakadAbschluss_adj"),
         BeschaeftigtemitakadAbschluss=my_ts_imputer(.,"BeschaeftigtemitakadAbschluss"),
         BeschaeftigteohneAbschluss_adj=my_ts_imputer(.,"BeschaeftigteohneAbschluss_adj"),
         BeschaeftigteohneAbschluss=my_ts_imputer(.,"BeschaeftigteohneAbschluss"),
         Einkommensteuer_ln=my_ts_imputer(.,"Einkommensteuer_ln"),
         Einkommensteuer=my_ts_imputer(.,"Einkommensteuer"),
         Haushaltseinkommen_ln=my_ts_imputer(.,"Haushaltseinkommen_ln"),
         Haushaltseinkommen=my_ts_imputer(.,"Haushaltseinkommen"),
         Schuldnerquote=my_ts_imputer(.,"Schuldnerquote"),
         BevoelkerungohneAbschluss=my_ts_imputer(.,"BevoelkerungohneAbschluss"),
         BevoelkerungmitakadAbschluss=my_ts_imputer(.,"BevoelkerungmitakadAbschluss"))
# hier wird der Datensatz mit den imputierten Werten generiert

# Result of Imputation
summary(as.data.frame(Impdata.imputed) %>% ungroup()  %>% select(listofdeterminants))



##Bestehende NAs in den NUTS2-Daten werden über Imputation auf Bundeslandebene gelöst
Impdata.imputed <- Impdata.imputed %>% mutate(BundeslandKZ = round(Kreis / 1000))

my_ts_imputer_NUTS2 <- function(data,outcome_name){
  mydata   <- data %>% group_by(BundeslandKZ) %>%
    select(BundeslandKZ,Jahr,"Outcome"=paste(outcome_name)) %>% 
    mutate(MEAN=mean(Outcome , na.rm=T)) %>% ungroup()
  mymodell <- lm(Outcome ~
                  I(Jahr*Jahr*MEAN) + I(Jahr*MEAN),
                   data = mydata  , na.action="na.exclude")
  mydata %>% select(Outcome) %>% mutate(Imputed = predict(mymodell, newdata =mydata )) %>%
    mutate(Outcome=ifelse(is.na(Outcome),Imputed,Outcome)) %>% 
    mutate(Outcome=ifelse(Outcome<0,0,Outcome)) %>% pull(Outcome)
}

Impdata.imputed <- Impdata.imputed %>%
  mutate(BevoelkerungohneAbschluss=my_ts_imputer_NUTS2(.,"BevoelkerungohneAbschluss"),
         BevoelkerungmitakadAbschluss=my_ts_imputer_NUTS2(.,"BevoelkerungmitakadAbschluss"))

summary(as.data.frame(Impdata.imputed) %>% ungroup()  %>% select(listofdeterminants))

Impdata.imputed <- Impdata.imputed %>% select(-BundeslandKZ)


########Imputation für Schulabgänger mit Hochschulreife
# Die Schulabgänger mit Hochschulreife werden separat imputiert und durch alle Kovariaten informiert

my_ts_imputer <- function(data,outcome_name){
  mydata   <- data %>%
    select(Gemeindekennziffer,Jahr,Arbeitslosigkeit,SchulabgaengerohneAbschluss_adj,Beschaeftigtenquote,Bruttoverdienst_ln,BeschaeftigtemitakadAbschluss_adj,BeschaeftigteohneAbschluss_adj,Einkommensteuer_ln,Haushaltseinkommen_ln,"Outcome"=paste(outcome_name)) %>% mutate(MEAN=mean(Outcome , na.rm=T))
  mymodell <- lm(Outcome ~
                  I(Jahr*Jahr*MEAN) + I(Jahr*MEAN) + Arbeitslosigkeit + 
                   SchulabgaengerohneAbschluss_adj + Beschaeftigtenquote + Bruttoverdienst_ln + BeschaeftigtemitakadAbschluss_adj + BeschaeftigteohneAbschluss_adj + Einkommensteuer_ln + Haushaltseinkommen_ln ,
                   data = mydata  , na.action="na.exclude")
  mydata %>% select(Outcome) %>% mutate(Imputed = predict(mymodell, newdata =mydata )) %>%
    mutate(Outcome=ifelse(is.na(Outcome),Imputed,Outcome)) %>% 
    mutate(Outcome=ifelse(Outcome<0,0,Outcome)) %>% pull(Outcome)
}

Impdata.imputed <- Impdata.imputed %>% mutate(
  SchulabgaengermitHochschulreife_adj=my_ts_imputer(.,"SchulabgaengermitHochschulreife_adj"),
  SchulabgaengermitHochschulreife=my_ts_imputer(.,"SchulabgaengermitHochschulreife")
  )

summary(Impdata.imputed$SchulabgaengermitHochschulreife_adj)





#Checken auf Missingwerte
missings_table = as.data.frame(expand.grid("Jahr"=1998:max(Impdata.imputed$Jahr)))
predictors_list = data.frame(Variable=character(), Missings=double(), stringsAsFactors = FALSE)
for (x in listofdeterminants){
  for (year in 1998:max(Impdata.imputed$Jahr)){
    missings_table[year-1997,x] = Impdata.imputed %>% filter(Jahr==year, is.na(Impdata.imputed[,x])) %>% nrow()
  }
  predictors_list[nrow(predictors_list) + 1,] = c(x, Impdata.imputed %>% filter(is.na(Impdata.imputed[,x])) %>% nrow())
}
predictors_list = predictors_list %>% mutate(Missings=as.integer(Missings))
predictors_list = predictors_list[order(predictors_list$Missings),]
predictors_list

#Missing betrachten
Missing_on_Imputationsvars <- Impdata.imputed %>%  filter(is.na(Einkommensteuer_ln))
Missing_on_Imputationsvars


# Fälle betrachten: 16063104
TimeSeries_for_Missing <- Impdata.imputed %>%  filter(Gemeindekennziffer==16063104) %>% arrange(Gemeindekennziffer, Jahr, Bevoelkerung)
TimeSeries_for_Missing

#Aufgrund der variierenden Verfübarkeit von Daten und der Unklarheit über die Indikatoren auf Gemeindeebene, werden die Gemeinden vorerst ausgeschlossen.
Impdata.imputed <- Impdata.imputed %>% filter(Gemeindekennziffer!=16063104)
TimeSeries <- Impdata.imputed %>%  filter(Gemeindekennziffer==16063104) %>% select(Gemeindekennziffer, Jahr, listofdeterminants) %>% arrange(Gemeindekennziffer, Jahr)
TimeSeries
```

- Ausschreiben des aktuellen Datensatzes als STATA- und RDS-File

```{r}
# Stata-Datensatz rausschreiben
stata_data <- Impdata.imputed %>% 
  mutate(SchulabgmitAbi_adj = SchulabgaengermitHochschulreife_adj, BeschaeftigteohneAbschlussadj = BeschaeftigteohneAbschluss_adj, BeschaeftigtemitakadAbschlussadj = BeschaeftigtemitakadAbschluss_adj) %>% 
  select(-SchulabgaengermitHochschulreife_adj,
         -BeschaeftigteohneAbschluss_adj,
         -BeschaeftigtemitakadAbschluss_adj)
write_dta(stata_data, paste0("Outfiles/",currentrevision,"/Stata/Impdata_check_2019.dta"))
rm(stata_data)

# RDS-Datensatz rausschreiben
write_rds(Impdata.imputed, paste0("Outfiles/",currentrevision,"/Impdata_check.rds"))

```


- weitere Histrogramme zur Überprüfung der Adjustments

```{r Histograms for List of Determinants, eval=FALSE, message=TRUE, include=FALSE, results="HIDE"}

library(ggplot2)
for(i in listofdeterminants){
hist_over_year <- ggplot(data = Impdata.imputed) + 
  geom_histogram(mapping =  aes_string(x = i)) + 
  facet_wrap(~Jahr)
print(hist_over_year)
}

hist_over_all <- ggplot(data = Impdata.imputed) + geom_histogram(mapping = aes_string(x = "BeschaeftigteohneAbschluss")) 
print(hist_over_all)


hist_over_westost <- ggplot() +
  geom_histogram(data = Impdata.imputed[Impdata.imputed[,"Kreis"]<11000,], aes_string(x = "BeschaeftigteohneAbschluss"), fill ='darkblue')  + 
  geom_histogram(data = Impdata.imputed[Impdata.imputed[,"Kreis"]>=11000,], aes_string(x = "BeschaeftigteohneAbschluss"), fill ='darkred')  
print(hist_over_westost)

hist_over_year_all <- ggplot(data = Impdata.imputed) + geom_histogram(mapping = aes_string(x = "BeschaeftigteohneAbschluss")) + facet_wrap(~Jahr)
print(hist_over_year_all)

hist_over_westost_adj <- ggplot() +
  geom_histogram(data = Impdata.imputed[Impdata.imputed[,"Kreis"]<11000,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkblue')  + 
  geom_histogram(data = Impdata.imputed[Impdata.imputed[,"Kreis"]>=11000,], aes_string(x = "BeschaeftigteohneAbschluss_adj"), fill ='darkred')
hist_over_westost_adj

# Es gibt eine bimodale Verteilung bei den Beschäftigten ohne Abschluss, die in Ost- und Westdeutschland jedoch unimodal ist
```



## IV. Faktorenanalyse (Hauptkomponentenanalyse) inklusive Generierung der Faktorscores

- Herunterbrechen der Indikatoren in die einzelnen Teildimensonen

```{r Tibbles für die Teilscores generieren, echo=FALSE}
TS_Arbeitswelt_adj <- Impdata.imputed  %>% ungroup() %>% filter(Jahr > 1999) %>% select(Beschaeftigtenquote,Arbeitslosigkeit,Bruttoverdienst_ln)

TS_Einkommen_adj   <- Impdata.imputed %>% ungroup %>% filter(Jahr > 1999) %>% select(Einkommensteuer_ln,Haushaltseinkommen_ln,Schuldnerquote) 

TS_Bildung_adj <- Impdata.imputed %>% ungroup %>% filter(Jahr > 1999) %>% select(BeschaeftigtemitakadAbschluss_adj,BeschaeftigteohneAbschluss_adj,SchulabgaengerohneAbschluss_adj) 
```


# Faktorenanalyse basierend auf Hauptkomponentenanalyse für jede der drei Subscalen

- PCA für jede Dimension

```{r PCA für die Teilscores, echo=FALSE}
# PCA für die Arbeitsweltdimension
TS_Arbeitswelt_adj.pca <- prcomp(TS_Arbeitswelt_adj, center = TRUE, scale. = TRUE, retx=TRUE)
plot(TS_Arbeitswelt_adj.pca)

TS_Arbeitswelt_adj.pca <- prcomp(TS_Arbeitswelt_adj, center = TRUE, scale. = TRUE, retx=TRUE, rank. = 1)
TS_Arbeitswelt_adj.pca


# PCA für die Einkommensdimension
TS_Einkommen_adj.pca <- prcomp(TS_Einkommen_adj, center = TRUE, scale. = TRUE, retx=TRUE) 
plot(TS_Einkommen_adj.pca)
TS_Einkommen_adj.pca <- prcomp(TS_Einkommen_adj, center = TRUE, scale. = TRUE, retx=TRUE, rank. = 1) 
TS_Einkommen_adj.pca


# PCA für die Bildungsdimension
TS_Bildung_adj.pca <- prcomp(TS_Bildung_adj, center = TRUE, scale. = TRUE, retx=TRUE) 
plot(TS_Bildung_adj.pca)
TS_Bildung_adj.pca <- prcomp(TS_Bildung_adj, center = TRUE, scale. = TRUE, retx=TRUE, rank. =1 ) 
TS_Bildung_adj.pca
```


# Nun wird die Generierung der Faktorscores vorbereitet.

- Erstellen einer Tablle zu den einzelnen Faktorladungen (wie Faktoranalyse-RMD)
- Prediction des GISD-Scores
- Polen der Dimensionen
- Normalisierung des Scores für jedes Jahr
- Ausschreiben des aktuellen Datensatzes

```{r Generierung der Faktorscores, echo=FALSE}
# Componentoverview
GISD_Komponents <- cbind("Teildimension"="Arbeitswelt","Anteil"=TS_Arbeitswelt_adj.pca$rotation^2,"Score"=TS_Arbeitswelt_adj.pca$rotation) 
GISD_Komponents <- rbind(GISD_Komponents,cbind("Teildimension"="Einkommen","Anteil"=TS_Einkommen_adj.pca$rotation^2,"Score"=TS_Einkommen_adj.pca$rotation)) 
GISD_Komponents <- rbind(GISD_Komponents,cbind("Teildimension"="Bildung (adj.)","Anteil"=TS_Bildung_adj.pca$rotation^2,"Score"=TS_Bildung_adj.pca$rotation)) 
GISD_Komponents <- cbind("Variables"=as.data.frame(rownames(GISD_Komponents)),as.data.frame(GISD_Komponents))

rownames(GISD_Komponents) <- NULL
colnames(GISD_Komponents) <- c("Variable","Dimension","Anteil","Score")
GISD_Komponents$GISD <- "GISD"
GISD_Komponents$Proportion <- round(as.numeric(as.character(GISD_Komponents$Anteil))*100,digits=1)


# Hier findet die Prediction der Scores statt
Resultdataset <- Impdata.imputed
Resultdataset$TS_Arbeitswelt_adj <- as.numeric(predict(TS_Arbeitswelt_adj.pca, newdata = Impdata.imputed))
Resultdataset$TS_Einkommen_adj <- as.numeric(predict(TS_Einkommen_adj.pca , newdata = Impdata.imputed))
Resultdataset$TS_Bildung_adj <- as.numeric(predict(TS_Bildung_adj.pca , newdata = Impdata.imputed))

summary(Resultdataset %>% select(TS_Arbeitswelt_adj, TS_Einkommen_adj, TS_Bildung_adj))
descs <- stat.desc(Resultdataset[, -5])


# Korrelationen überprüfen
Resultdataset %>% select(Arbeitslosigkeit,TS_Arbeitswelt_adj,TS_Einkommen_adj,TS_Bildung_adj)  %>% cor( use="pairwise.complete.obs")

#sie werden so gepolt, dass sie positiv mit Arbeitslosigkeit korrelieren, um Deprivation abzubilden
if (cor(Resultdataset$Arbeitslosigkeit, Resultdataset$TS_Bildung_adj,use="pairwise.complete.obs")<0) {
   Resultdataset$TS_Bildung_adj <- Resultdataset$TS_Bildung_adj*-1
   }
if (cor(Resultdataset$Arbeitslosigkeit, Resultdataset$TS_Arbeitswelt_adj,use="pairwise.complete.obs")<0) {
  Resultdataset$TS_Arbeitswelt_adj <- Resultdataset$TS_Arbeitswelt_adj*-1
  }
if (cor(Resultdataset$Arbeitslosigkeit, Resultdataset$TS_Einkommen_adj,use="pairwise.complete.obs")<0) {
  Resultdataset$TS_Einkommen_adj <- Resultdataset$TS_Einkommen_adj*-1
}

# Korrelationen erneut überprüfen
Resultdataset %>% select(Arbeitslosigkeit,TS_Arbeitswelt_adj,TS_Einkommen_adj,TS_Bildung_adj) %>% cor( use="pairwise.complete.obs")


GISD_Komponents

# Tabelle der Komponenten mit den Anteilen ausgeben und gespeichert
save(GISD_Komponents, file=paste0("Outfiles/",currentrevision,"/GISD_Komponents.RData"))



# Normalization
Resultdataset$TS_Arbeitswelt_adj <- (Resultdataset$TS_Arbeitswelt_adj -min(Resultdataset$TS_Arbeitswelt_adj ))/(max(Resultdataset$TS_Arbeitswelt_adj )-min(Resultdataset$TS_Arbeitswelt_adj ))
Resultdataset$TS_Einkommen_adj <- (Resultdataset$TS_Einkommen_adj -min(Resultdataset$TS_Einkommen_adj ))/(max(Resultdataset$TS_Einkommen_adj )-min(Resultdataset$TS_Einkommen_adj ))
Resultdataset$TS_Bildung_adj <- (Resultdataset$TS_Bildung_adj -min(Resultdataset$TS_Bildung_adj ))/(max(Resultdataset$TS_Bildung_adj )-min(Resultdataset$TS_Bildung_adj ))


# GISD
Resultdataset$GISD_Score <- Resultdataset$TS_Arbeitswelt_adj+Resultdataset$TS_Einkommen_adj+Resultdataset$TS_Bildung_adj
for (i in 1998:currentyear) {
  Resultdataset <- Resultdataset %>% group_by(Jahr) %>% mutate(GISD_Score = ifelse(Jahr == i,(GISD_Score -min(GISD_Score))/(max(GISD_Score)-min(GISD_Score)), GISD_Score)) %>% ungroup()
}

Resultdataset <- Resultdataset %>% mutate(GISD_Score = round(GISD_Score , digits = 5))

# Result
summary(Resultdataset %>% select(TS_Arbeitswelt_adj,TS_Einkommen_adj,TS_Bildung_adj,GISD_Score))
str(Resultdataset %>% select(TS_Arbeitswelt_adj,TS_Einkommen_adj,TS_Bildung_adj,GISD_Score))


# Teilscores und GISD-Score in Datensatz speichern
Resultdataset <- Resultdataset %>% select(Gemeindekennziffer,Jahr,Bevoelkerung,contains("TS_"),contains("GISD_Score"))

write_rds(Resultdataset, paste0("Outfiles/",currentrevision,"/Resultdataset.rds"))
write_dta(Resultdataset, paste0("Outfiles/",currentrevision,"/Stata/Resultdataset.dta"))
```

## V.  Datenexport - Erstellung der Datensätze 

- Ausschreibeen des GISD-Scores in den Outfiles-Ordner (für Bund und Bundesland; jeweils als .csv oder .dta für Stata)

```{r echo=FALSE}
# Merge IDs to Resultdataset
RawResult <- left_join(Resultdataset %>%
                         select(-Bevoelkerung),
                       id_dataset,
                       by = "Gemeindekennziffer")


RawResult <- RawResult %>% rename(year = Jahr, 
                                  population = Bevoelkerung,  #y
                                  gisd_score = GISD_Score,    #x
                                  gemeinde_id = Gemeindekennziffer,
                                  gvb_id = GVBKennziffer,     #y
                                  kreis_id = Kreiskennziffer, #y
                                  ror_id = `Raumordnungsregion Nr`,
                                  nuts_2_id = NUTS2,
                                  gemeinde_name = `Name der Gemeinde`,
                                  gvb_name = `Name des Gemeindeverbands`,
                                  kreis_name = `Name des Kreises`,
                                  ror_name = Raumordnungsregion,
                                  nuts_2_name = `NUTS2 Name`) %>%
                            mutate(gemeinde_id = as.character(as.vector(gemeinde_id)),
                                   gemeinde_id = ifelse(nchar(gemeinde_id)==7,paste0("0",gemeinde_id),gemeinde_id),
                                   gvb_id = as.character(gvb_id),
                                   gvb_id = ifelse(nchar(gvb_id)==8,paste0("0",gvb_id),gvb_id),
                                   kreis_id = as.character(kreis_id),
                                   kreis_id = ifelse(nchar(kreis_id)==4,paste0("0",kreis_id),kreis_id),
                                   ror_id = as.character(ror_id),
                                   ror_id = ifelse(nchar(ror_id)==3,paste0("0",ror_id),ror_id))



exportlist<- NULL
exportlist$Kennziffern <- c("gemeinde_id","kreis_id","gvb_id","ror_id","nuts_2_id")
exportlist$Namen <- c("gemeinde_name","kreis_name","gvb_name","ror_name","nuts_2_name")
exportlist$Label <- c("Gemeinde","Kreis","Gemeindeverband","Raumordnungsregion","NUTS2")


# exportlist$Kennziffern <- c("Gemeindekennziffer") # for testing
  

# Es folgt eine sehr lange Schleife
# für alle Regionalkennziffern (siehe Vektor) werden Datensätze generiert und in Ordnern abgelegt
for(mykennziffer in exportlist$Kennziffern) {
  myname <-  exportlist$Namen[exportlist$Kennziffern==mykennziffer]
  mylabel<-  exportlist$Label[exportlist$Kennziffern==mykennziffer]
  print(paste("Level:",myname,"Label:",mylabel))
  
  # Datensatzerstellung
  outputdata <- RawResult 
  
  outputdata$Group <- outputdata[[mykennziffer]]
  mergedataset  <- outputdata %>% select(ID=mykennziffer,myname,Bundesland) %>% 
    group_by(ID) %>% filter(row_number()==1) %>% ungroup() 
  names(mergedataset)[1]=mykennziffer
  
  # Aggregation
  outputdata.agg <- outputdata %>% 
    group_by(Group,year) %>% 
    select(Group,year,"population",gisd_score, TS_Bildung_adj, TS_Einkommen_adj, TS_Arbeitswelt_adj) %>% 
    summarise(gisd_score = weighted.mean(gisd_score, population), 
              TS_Bildung_adj = weighted.mean(TS_Bildung_adj, population), 
              TS_Einkommen_adj = weighted.mean(TS_Einkommen_adj, population),
              TS_Arbeitswelt_adj = weighted.mean(TS_Arbeitswelt_adj, population),
              population = sum(population))
  
  
  
   #hier werden die bevoelkerungsgewichteten Mittelwerte über die regionalen Einheiten gebildet
   #Achtung: Referenzrahmen für den Bevölkerungsstand ist das Referenzjahr. Die Varianz der Bevölkerung über die Jahre wird nicht berücksichtigt.
  
  # Daten bereinigen
  names(outputdata.agg)[1] <- mykennziffer
  outputdata.agg <- merge(outputdata.agg,mergedataset,by=mykennziffer) %>%  
    select(mykennziffer,myname,year,Bundesland,"population",gisd_score, TS_Bildung_adj, TS_Einkommen_adj, TS_Arbeitswelt_adj) %>%
    group_by(year) %>% as_tibble()
  
  # Rekodierung
  # hier wird der GISD-Score neu normalisiert und die Quintile gebildet
  for (i in 1998:currentyear) {
  outputdata.agg <- outputdata.agg %>% group_by(year) %>% mutate(gisd_score = ifelse(year == i,(gisd_score -min(gisd_score))/(max(gisd_score)-min(gisd_score)), gisd_score))
}
  outputdata.agg <- outputdata.agg %>% group_by(year) %>% mutate(gisd_5 = findInterval(gisd_score, quantile(gisd_score,   probs=0:5/5 , type=9)),
                                        gisd_5 = findInterval(gisd_5, c(1:5)),
                                        gisd_10 = findInterval(gisd_score, quantile(gisd_score, probs=0:10/10 , type=9)),
                                        gisd_10 = findInterval(gisd_10, c(1:10)),
                                        gisd_k = findInterval(gisd_5, c(1,2,5))) %>% ungroup()
                                       
  summary(outputdata.agg %>% select(contains("gisd")))
  
  outputdata.agg <- outputdata.agg %>% mutate(gisd_score = round(gisd_score, digits = 5))
  
  # Aktuelles Referenzmodell 


  # Ausgabe Bund
  mydata <- outputdata.agg %>% ungroup() %>% select(mykennziffer, gisd_score, gisd_5, gisd_10, gisd_k, myname, year)
  write.csv(mydata, paste0("Outfiles/",currentrevision,"/Bund/GISD_Bund_",mylabel,".csv"), row.names=FALSE, fileEncoding="UTF-8")
  
  names(mydata) <- gsub("\\.","_",make.names(names(mydata)))
  names(mydata) <- gsub("\\?","oe",names(mydata))
  names(mydata) <- gsub("\\?","ae",names(mydata))
  names(mydata) <- gsub("\\?","ue",names(mydata))
  names(mydata) <- gsub("\\?","ss",names(mydata))
  write_dta(mydata, paste0("Outfiles/",currentrevision,"/Bund/GISD_Bund_",mylabel,"_long.dta"))
  
  
  
  
  
  # Ausgabe Bundeslandspezifisch ohne Stadtstaaten und nur für Ebenen Kreis und Gemeindeverband
  if (mylabel %in% c("Gemeinde","Gemeindeverband","Kreis")) {
    
    # Datensatzerstellung
  outputdata <- RawResult 
  
  outputdata$Group <- outputdata[[mykennziffer]]
  mergedataset  <- outputdata %>% dplyr::select(ID=mykennziffer,myname,Bundesland) %>% 
    group_by(ID) %>% filter(row_number()==1) %>% ungroup() 
  names(mergedataset)[1]=mykennziffer
    
    
      # Aggregation
  outputdata.bula <- outputdata %>% 
    group_by(Group,year) %>% 
    dplyr::select(Group,year,"population",gisd_score, TS_Bildung_adj, TS_Einkommen_adj, TS_Arbeitswelt_adj) %>% 
    summarise(gisd_score = weighted.mean(gisd_score, population), 
              TS_Bildung_adj = weighted.mean(TS_Bildung_adj, population), 
              TS_Einkommen_adj = weighted.mean(TS_Einkommen_adj, population),
              TS_Arbeitswelt_adj = weighted.mean(TS_Arbeitswelt_adj, population),
              population = sum(population))
  
  
  # Daten bereinigen
  names(outputdata.bula)[1] <- mykennziffer
  outputdata.bula <- merge(outputdata.bula,mergedataset,by=mykennziffer) %>%  
    select(mykennziffer,myname,year,Bundesland,"population",gisd_score, TS_Bildung_adj, TS_Einkommen_adj, TS_Arbeitswelt_adj) %>%
    group_by(year) %>% as_tibble()
    
  outputdata.bula <- outputdata.bula %>% ungroup() %>% filter(!(Bundesland %in% c("Bremen","Hamburg","Berlin"))) %>% group_by(year,Bundesland)
  
  
  # Rekodierung Bundesland
  for (i in 1998:currentyear) {
  outputdata.bula <- outputdata.bula %>%
    group_by(year, Bundesland) %>%
    mutate(gisd_score = ifelse(year == i,
                               (gisd_score -min(gisd_score))/(max(gisd_score)-min(gisd_score)),
                               gisd_score)) %>% ungroup()
  }
                         
  summary(outputdata.bula %>%
            select(contains("gisd")))
  
  outputdata.bula <- outputdata.bula %>%
    mutate(gisd_score = round(gisd_score, digits = 5))
  
  # Ausgabe Bundesländer
  ListeBula <- unique(outputdata.bula$Bundesland) 
  for(myland in ListeBula) {
    mydata.bula <- outputdata.bula %>% filter(Bundesland==myland) %>% ungroup() %>% select(gisd_score, mykennziffer, myname, year)
    write.csv(mydata.bula, paste0("Outfiles/",currentrevision,"/Bundesland/GISD_",myland,"_",mylabel,".csv"), row.names=FALSE, fileEncoding="UTF-8")
    
    names(mydata.bula) <- gsub("\\.","_",make.names(names(mydata.bula)))
    names(mydata.bula) <- gsub("\\?","oe",names(mydata.bula))
    names(mydata.bula) <- gsub("\\?","ae",names(mydata.bula))
    names(mydata.bula) <- gsub("\\?","ue",names(mydata.bula))
    names(mydata.bula) <- gsub("\\?","ss",names(mydata.bula))
    write_dta(mydata.bula, paste0("Outfiles/",currentrevision,"/Bundesland/GISD_",myland,"_",mylabel,".dta"))
    }
  }  
}

```


## VI.  Datensätze für PLZ generieren

- Ausschreiben des GISD-Scores nach Postleitzahl

```{r eval=FALSE, include=FALSE}
# Output Postcode Data
load("Data/SHP/GEM_Zipcode_Intersections_2015.RData") # AGS/Postcode-Intersections-Dataset in sf format


for (mykennziffer in c("PLZ2","PLZ3","PLZ4","PLZ5")) {
  myname <-  paste0(mykennziffer)
  mylabel <-  paste0(mykennziffer)
  print(paste("Level:",myname,"Label:",mylabel))
  
  # Datensatzerstellung
  outputdata <- Resultdataset
  
  outputdata <- outputdata %>% rename(gemeinde_id = Gemeindekennziffer, year = Jahr, gisd_score = GISD_Score)
  
  outputdata <- outputdata %>% select(AGS=gemeinde_id,year,gisd_score)
  outputdata <- left_join(as.data.frame(PLZ.df) %>% ungroup() %>% mutate(AGS=as.numeric(as.character(AGS))),
                          outputdata,by=c("AGS"), all.x = TRUE)
  
  outputdata <- outputdata %>% mutate(AGS = as.character(AGS),
                                      AGS = ifelse(nchar(AGS)<8,paste0("0",AGS),AGS))
  
  outputdata <- outputdata %>% filter(!is.na(mykennziffer) & !is.na(EW_Area) & !is.na(year) & EW_Area>0)
  mycol <- which(mykennziffer %in% names(outputdata))
  outputdata <- outputdata %>% group_by(year,AGS) 
  outputdata <- outputdata %>% mutate(gisd_score = weighted.mean(gisd_score,EW_Area))
  #names(outputdata)[names(outputdata)=="year"]<- "JAHR" # Seltsames Problem Name "Jahr"
  outputdata <- outputdata %>% group_by_at(vars("year",mykennziffer)) %>% 
    summarise(gisd_score = weighted.mean(gisd_score,EW_Area), population = sum(EW_Area)) %>%
    group_by(year)
  
  outputdata <- outputdata %>%  mutate(gisd_score = round((gisd_score -min(gisd_score ))/(max(gisd_score )-min(gisd_score)), digits=6),
                                       gisd_5 = findInterval(gisd_score, quantile(gisd_score,   probs=0:5/5 , type=9)),
                                       gisd_5 = findInterval(gisd_5, c(1:5)),
                                       gisd_10 = findInterval(gisd_score, quantile(gisd_score, probs=0:10/10 , type=9)),
                                       gisd_10 = findInterval(gisd_10, c(1:10)),
                                       gisd_k = findInterval(gisd_5, c(1,2,5)))
  summary(outputdata)            
  head(outputdata)
  ListeJahre <- unique(outputdata$year)
  mydata <- outputdata %>% ungroup() 
  write.csv(mydata, paste0("Outfiles/",currentrevision,"/Bund/GISD_Bund_",mylabel,".csv"), row.names=FALSE, fileEncoding="UTF-8")
  mydata <- outputdata %>% ungroup() 
  names(mydata) <- gsub("\\.","_",make.names(names(mydata)))
  names(mydata) <- gsub("\\?","oe",names(mydata))
  names(mydata) <- gsub("\\?","ae",names(mydata))
  names(mydata) <- gsub("\\?","ue",names(mydata))
  names(mydata) <- gsub("\\?","ss",names(mydata))
  write_dta(mydata, paste0("Outfiles/",currentrevision,"/Bund/GISD_Bund_",mylabel,"_long.dta"))
  }
```